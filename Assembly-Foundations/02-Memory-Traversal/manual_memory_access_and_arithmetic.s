@DAY-2-CHALLENGE RUN #2, NO HELP
@STORE TWO INTEGERS "a" AND "b" IN THE STACK, WRITE THEM TO THE REGISTERS USING DIFFERENT FORMS OF ADDRESSING, THEN USE ARITHMETIC OPERATORS (ADD,SUB,MUL) ON THE TWO INTEGERS, AND SAVE THEM
@BACK TO THE STACK IN SEQUENTIAL ORDER FROM THE END OF THE LIST OF WHICH "a" AND "b" WERE INITIALLY STORED

.global _start
_start:
	MOV R0,=list @USING LITERAL ADDRESSING TO SET BASE-REGISTER/POINTER TO THE STACK ADDRESS OF FIRST ENTRY WITHIN THE LIST
	LDR R1,[R0] @USING INDIRECT ADDRESSING TO WRITE THE CONTENTS OF OUR FIRST ENTRY WITHIN THE LIST TO REGISTER 1 ) LIST[0]=6
	LDR R2,[R0,#4] @USING INDIRECT ADDRESSING + 4-BYTE OFFSET TO WRITE THE CONTENTS OF THE SECOND ENTRY WITHIN THE LIST TO REGISTER 2 ) LIST[1]=10
	ADD R3,R1,R2 @PERFORMING THE ADD OP-CODE TO ADD THE CONTENTS WRITTEN INTO REGISTERS 1/2 AND PLACE THE RESULT INTO REGISTER 3 ) R3=R1+R2
	SUB R4,R1,R2 @PERFORMING THE SUB OP-CODE TO SUBTRACT THE CONTENTS WRITTEN INTO REGISTER 2 FROM REGISTER 1, AND PLACING THE RESULT INTO REGISTER 4 ) R4=R1-R2
	MUL R5,R1,R2 @PERFORMING THE MUL OP-CODE TO MULTIPLY THE CONTENTS WRITTEN INTO REGISTERS 1/2, AND PLACING THE RESULT INTO REGISTER 5 ) R5=R1*R2
	STR R3,[R0,#8] @STORING THE CONTENTS OF REGISTER 3 SUBSEQUENTLY AFTER OUR LAST ENTRY WITHIN THE LIST, WE DO THIS BY TAKING OUR ORIGINAL POINTER AND OFFSETTING IT BY 8-BYTES TO GET TO THE THIRD POSITION WITHIN THE LIST ) LIST[2]=R3
	STR R4,[R0,#12] @STORING THE CONTENTS OF REGISTER 4 SUBSEQUENTLY AFTER OUR LAST ENTRY WITHIN THE LIST, WE DO THIS BY TAKING OUR ORIGINAL POINTER AND OFFSETTING IT BY 12-BYTES TO GET TO THE FOURTH POSITION WITHIN THE LIST ) LIST[3]=R4
	STR R5,[R0,#16] @STORING THE CONTENTS OF REGISTER 5 SUBSEQUENTLY AFTER OUR LAST ENTRY WITHIN THE LIST, WE DO THIS BY TAKING OUR ORIGINAL POINTER AND OFFSETTING IT BY 16-BYTES TO GET TO THE FIFTH POSITION WITHIN THE LIST ) LIST[4]=R5

.data
list:
	.word 6,10 @OUR TWO INTEGERS, a=6, b=10, LIST[0]=6, LIST[1]=10

	@I HAVE NOW WRITTEN A PROGRAM, THIS IS WHAT IT DOES: STORES TWO INTEGERS "A" AND "B" WITHIN THE STACK MEMORY, WITH ONE BEING AFTER ANOTHER, IN THE FORM OF A LIST OF DATA. I DEFINED THE LISTS DATA AS EACH INDIVIDUAL ENTRY BEING ONE "WORD" OF LENGTH
	@I THEN CREATED A POINTER TO THE BEGINNING OF THAT LIST WITHIN THE STACK AND STORED IT WITHIN REGISTER 0 USING THE "=LIST" OP-CODE, FROM THERE I DEREFERENCED THE POINTER AND WROTE THE CONTENTS OF THAT INITIAL LIST ENTRY ONTO REGISTER 1
	@THUS RESULTING IN REGISTER 1 BEING WRITTEN WITH THE HEX VALUE OF OUR INTEGER "a", AFTER THAT I USED THE "LDR" OP-CODE TO THEN WRITE OUR SECOND INTEGER WITHIN THE LIST "b" TO REGISTER 2, VIA INDIRECTLY ADDRESSING THE REGISTER WITH AN OFFSET
	@OF 4-BYTES, ESSENTIALLY SKIPPING THE FIRST STACK MEMORY ADDRESS WITHIN THE LIST AND MOVED TO THE SECOND ONE, THUS STORING OUR SECOND INTEGER WITHIN REGISTER 2
	@AFTER THAT I USED THE ARITHMETIC OPERATORS "ADD,SUB,MUL" TO CARRY OUT THE OPERATIONS USING INTEGERS "a" AND "b" WHICH WERE WRITTEN INTO REGISTERS 1 AND TWO, R3 WAS WRITTEN WITH THE SUM OF THESE TWO INTEGERS, R4 WAS WRITTEN WITH THE DIFFERENCE
	@OF THESE TWO INTEGERS, AND R5 WAS WRITTEN WITH THE MULTIPLICATION OF THESE TWO INTEGERS.
	@FINALLY, I USE THE "STR" OP-CODE TO WRITE THE CONTENTS OF REGISTERS R3,R4, AND R5 BACK INTO THE STACK, AND IN CONSECUTIVE ORDER FOLLOWING THE MEMORY ADDRESSES FROM THE INITIAL TWO ENTRIES WITHIN OUR LIST OF DATA.
	@SO NOW, WHEN VIEWING THE STACK FROM OUR BASE-REGISTER/POINTER (R0), OUR LIST SHOULD LOOK LIKE THIS: LIST[0]=6, LIST[1]=10, LIST[2]=16, LIST[3]=-4, LIST[4]=60.

	@WHAT I COULD HAVE DONE DIFFERENTLY: I COULD HAVE USED A POST-INCREMENT ADDRESSING MODE TO TRAVERSE THE LIST OF INTEGERS A AND B MORE EFFICIENTLY, FOR EXAMPLE, I COULD HAVE USED
	@ -> LDR R1,[R0],#4 , TO WRITE THE CONTENTS OF THE BASE-REGISTER/POINTER TO THE REGISTER (R1), AND THEN INCREMENT/UPDATE THE BASE-REGISTERS STACK MEMORY ADDRESS POINTER TO R0+4-BYTES
